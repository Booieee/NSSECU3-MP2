"""
Python 3 Forensic File Scanner for File001..File220
====================================================

Finds files named File001 through File220 on a mounted disk image.
Classifies by generic file signatures (magic numbers). Detects malware
indicators without YARA. Displays results in old scanner format.

Author: Forensic Analysis Tool
Date: February 2026
"""

import os
import csv
import hashlib
import re
import ctypes
from typing import Dict, List, Tuple, Set
from collections import Counter


# =============================================================================
# CONSTANTS
# =============================================================================

FILE_ID_PATTERN = re.compile(r"^File(\d{3})$", re.IGNORECASE)

# Malware indicator rules (no YARA)
MALWARE_RULES = [
    {"id": "URL_PROTOCOL", "target": "text", "match_type": "regex", "pattern": r"(https?|ftp|sftp|ws|wss)://", "severity": 1},
    {"id": "IPV4_LITERAL", "target": "text", "match_type": "regex", "pattern": r"\b(25[0-5]|2[0-4]\d|1?\d?\d)\.(25[0-5]|2[0-4]\d|1?\d?\d)\.(25[0-5]|2[0-4]\d|1?\d?\d)\.(25[0-5]|2[0-4]\d|1?\d?\d)\b", "severity": 1},
    {"id": "PS_ENCODED_FLAG", "target": "text", "match_type": "regex", "pattern": r"\b(powershell|pwsh)(\.exe)?\b[^\r\n]{0,200}-(encodedcommand|enc)\b", "severity": 3},
    {"id": "PS_BYPASS_FLAG", "target": "text", "match_type": "literal", "pattern": "-executionpolicy bypass", "severity": 1},
    {"id": "PS_HIDDEN_FLAG", "target": "text", "match_type": "literal", "pattern": "-windowstyle hidden", "severity": 1},
    {"id": "API_CREATE_REMOTE_THREAD", "target": "text", "match_type": "regex", "pattern": r"(createremotethreadex?|ntcreatethreadex|rtlcreateuserthread)", "severity": 2},
    {"id": "API_VIRTUAL_ALLOC", "target": "text", "match_type": "regex", "pattern": r"(virtualallocex?numa?|ntallocatevirtualmemory)", "severity": 2},
    {"id": "API_WRITE_PROCESS_MEMORY", "target": "text", "match_type": "regex", "pattern": r"(writeprocessmemory|ntwritevirtualmemory)", "severity": 2},
    {"id": "API_QUEUE_USER_APC", "target": "text", "match_type": "regex", "pattern": r"(queueuserapc|ntqueueapcthread)", "severity": 2},
    {"id": "API_WINEXEC", "target": "text", "match_type": "literal", "pattern": "winexec", "severity": 1},
    {"id": "API_SHELLEXECUTE", "target": "text", "match_type": "regex", "pattern": r"shellexecute(ex|a|w)?", "severity": 1},
    {"id": "REG_RUN_PERSISTENCE", "target": "text", "match_type": "literal", "pattern": "\\software\\microsoft\\windows\\currentversion\\run", "severity": 2},
    {"id": "REG_SET_VALUE", "target": "text", "match_type": "literal", "pattern": "regsetvalue", "severity": 1},
    {"id": "SUSPICIOUS_TERMS", "target": "text", "match_type": "regex", "pattern": r"(backdoor|reverse\s+shell|bind\s+shell|keylogger|ransom|stealer|miner)", "severity": 1},
]


# =============================================================================
# FILE TYPE DETECTION
# =============================================================================

def _is_text_content(header: bytes) -> bool:
    """Check if header looks like printable text."""
    if not header:
        return False
    sample = header[:4096]
    text_chars = sum(1 for b in sample if b in (9, 10, 13) or 32 <= b <= 126)
    return text_chars / len(sample) >= 0.90


def detect_file_type(path: str, header: bytes) -> Tuple[str, str]:
    """Detect file type from magic numbers. Returns (detected_type, signature_name)."""
    if len(header) < 4:
        return ("UNKNOWN", "")

    # Executables
    if header.startswith(b"MZ"):
        return ("EXE", "PE_MZ_HEADER")
    if header.startswith(b"\x7FELF"):
        return ("ELF", "ELF_HEADER")

    # Documents
    if header.startswith(b"%PDF-"):
        return ("PDF", "PDF_HEADER_V1")

    # Images
    if header.startswith(b"\x89PNG\r\n\x1a\n"):
        return ("PNG", "PNG_SIGNATURE")
    if header.startswith(b"\xFF\xD8\xFF"):
        return ("JPEG", "JPEG_GENERIC")
    if b"JFIF" in header[:512]:
        return ("JPEG", "JPEG_JFIF")
    if header.startswith(b"GIF87a") or header.startswith(b"GIF89a"):
        return ("GIF", "GIF_HEADER")
    if header.startswith(b"BM"):
        return ("BMP", "BMP_HEADER")

    # Archives
    if header.startswith(b"PK\x03\x04"):
        header_lower = header[:4096].lower()
        if b"word/" in header_lower:
            return ("ZIP", "OOXML_DOCX_HINT")
        if b"ppt/" in header_lower:
            return ("ZIP", "OOXML_PPTX_HINT")
        if b"xl/" in header_lower:
            return ("ZIP", "OOXML_XLSX_HINT")
        return ("ZIP", "ZIP_PK_HEADER")
    
    if header.startswith(b"\x37\x7A\xBC\xAF\x27\x1C"):
        return ("7Z", "7Z_HEADER")
    if header.startswith(b"Rar!\x1A\x07\x00") or header.startswith(b"Rar!\x1A\x07\x01\x00"):
        return ("RAR", "RAR_HEADER")
    if header.startswith(b"\x1F\x8B\x08"):
        return ("GZ", "GZIP_HEADER")

    # Multimedia
    if header.startswith(b"RIFF") and len(header) >= 12:
        form_type = header[8:12]
        if form_type == b"WAVE":
            return ("WAV", "RIFF_WAVE")
        if form_type == b"AVI ":
            return ("AVI", "RIFF_AVI")
        return ("RIFF", "RIFF_GENERIC")
    
    if len(header) >= 12 and header[4:8] == b"ftyp":
        return ("MP4", "MP4_FTYP_OFFSET4")

    # Databases
    if header.startswith(b"SQLite format 3\x00"):
        return ("SQLITE", "SQLITE_HEADER")

    # Audio
    if header.startswith(b"ID3"):
        return ("MP3", "MP3_ID3V2")
    if len(header) > 1 and header[0] == 0xFF and (header[1] & 0xE0) == 0xE0:
        return ("MP3", "MP3_ID3V1")

    # Shortcuts
    if header.startswith(b"\x4C\x00\x00\x00\x01\x14\x02\x00"):
        return ("LNK", "LNK_HEADER")

    # Text/Scripts
    if header.startswith(b"\xEF\xBB\xBF"):
        return ("PS1", "PS1_UTF8_BOM")
    
    stripped = header[:512].lstrip()
    if stripped.lower().startswith(b"@echo"):
        return ("BAT", "BAT_ECHO_OFF")
    
    # Office CD30 format
    if header.startswith(b"CD30"):
        return ("OFFICE", "OFFICE_CD30")
    
    if _is_text_content(header):
        return ("TXT", "TXT_HEURISTIC")

    return ("UNKNOWN", "")


# =============================================================================
# MALWARE INDICATOR DETECTION
# =============================================================================

def detect_malware_indicators(content: bytes) -> Tuple[List[str], int, str]:
    """Detect malware indicators. Returns (matched_rules, risk_score, verdict)."""
    text = content.decode("utf-8", errors="ignore").lower()
    matched_rules: List[str] = []
    score = 0

    for rule in MALWARE_RULES:
        target = rule["target"]
        match_type = rule["match_type"]
        pattern = rule["pattern"]
        matched = False

        if target == "text":
            if match_type == "literal":
                matched = pattern in text
            elif match_type == "regex":
                matched = re.search(pattern, text, flags=re.IGNORECASE) is not None
        elif target == "bytes":
            if match_type == "literal":
                matched = pattern in content
            elif match_type == "regex":
                matched = re.search(pattern, content) is not None

        if matched:
            matched_rules.append(rule["id"])
            score += int(rule["severity"])

    # Composite rules
    if "PS_ENCODED_FLAG" in matched_rules and re.search(r"[A-Za-z0-9+/]{80,}={0,2}", text):
        matched_rules.append("PS_ENCODED_PAYLOAD")
        score += 2

    has_remote_thread = "API_CREATE_REMOTE_THREAD" in matched_rules
    has_mem_api = (
        "API_VIRTUAL_ALLOC" in matched_rules or
        "API_WRITE_PROCESS_MEMORY" in matched_rules or
        "API_QUEUE_USER_APC" in matched_rules
    )
    if has_remote_thread and has_mem_api:
        matched_rules.append("PROCESS_INJECTION_PATTERN")
        score += 2

    # Verdict
    if score >= 5:
        verdict = "LIKELY_MALICIOUS"
    elif score >= 2:
        verdict = "SUSPICIOUS"
    else:
        verdict = "CLEAN"

    return (matched_rules, score, verdict)


# =============================================================================
# FILESYSTEM UTILITIES
# =============================================================================

def list_windows_drives() -> List[str]:
    """List mounted Windows drives."""
    if os.name != "nt":
        return ["/"]
    
    bitmask = ctypes.windll.kernel32.GetLogicalDrives()
    drives = []
    
    for i in range(26):
        if bitmask & (1 << i):
            drives.append(f"{chr(65 + i)}:\\")
    
    return drives


def read_file_header(path: str, num_bytes: int = 50) -> bytes:
    """Read first N bytes from file."""
    with open(path, "rb") as f:
        return f.read(num_bytes)


def read_file_sample(path: str, max_bytes: int = 1024 * 1024) -> bytes:
    """Read bounded sample from file."""
    with open(path, "rb") as f:
        return f.read(max_bytes)


def compute_sha256(path: str) -> str:
    """Calculate SHA256 hash of a file."""
    hasher = hashlib.sha256()
    with open(path, "rb") as f:
        while chunk := f.read(1024 * 1024):
            hasher.update(chunk)
    return hasher.hexdigest()


# =============================================================================
# CSV OUTPUT
# =============================================================================

def write_csv_report(results: List[Dict], output_path: str) -> None:
    """Write results to CSV."""
    fieldnames = [
        "file_path", "file_name", "file_size", "sha256",
        "first_50_bytes_hex", "detected_type", "signature_match",
        "malware_rule_hits", "risk_score", "verdict"
    ]
    
    with open(output_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames, extrasaction="ignore")
        writer.writeheader()
        writer.writerows(results)


# =============================================================================
# PROGRESS AND SUMMARY
# =============================================================================

def print_progress(total_encountered: int, total_flagged: int, latest_path: str) -> None:
    """Print progress update."""
    print(f"[PROGRESS] Files encountered: {total_encountered} | "
          f"Flagged: {total_flagged} | Latest: {latest_path}")


def print_summary(total_encountered: int, total_scanned: int, 
                 suspicious_count: int, unreadable: int, 
                 results: List[Dict]) -> None:
    """Print malware scan summary."""
    print("\n" + "=" * 70)
    print("MALWARE SCAN SUMMARY (NO YARA)")
    print("=" * 70)
    print(f"Total files encountered (overall):        {total_encountered}")
    print(f"Total files successfully scanned:         {total_scanned}")
    print(f"Total flagged (suspicious/malicious):     {suspicious_count}")
    print(f"Total unreadable files / errors:          {unreadable}")

    print("\n" + "-" * 70)
    print("GROUPED COUNT BY DETECTED FILE TYPE")
    print("-" * 70)
    type_counts = Counter(r["detected_type"] for r in results)
    for ftype, count in sorted(type_counts.items()):
        print(f"  {ftype:20s} : {count:4d}")

    print("\n" + "-" * 70)
    print("GROUPED COUNT BY VERDICT")
    print("-" * 70)
    verdict_counts = Counter(r.get("verdict", "CLEAN") for r in results)
    for verdict, count in sorted(verdict_counts.items()):
        print(f"  {verdict:20s} : {count:4d}")

    print("\n" + "-" * 70)
    print("TOP MATCHED MALWARE RULES")
    print("-" * 70)
    rule_counts: Counter = Counter()
    for row in results:
        hits = row.get("malware_rule_hits", "")
        if hits:
            for rule in hits.split(";"):
                if rule:
                    rule_counts[rule] += 1

    if rule_counts:
        for rule, count in rule_counts.most_common(10):
            print(f"  {rule:30s} : {count:4d}")
    else:
        print("  (No malware indicators matched)")


# =============================================================================
# MAIN SCANNER
# =============================================================================

def main():
    """Main scanner entry point."""
    print("=" * 70)
    print("PYTHON 3 FORENSIC FILE SCANNER FOR MOUNTED DISK IMAGES")
    print("=" * 70)
    print("Mode: Read-only (no files will be modified)")
    print("Detection: No-YARA malware indicators + magic numbers")
    print("=" * 70)
    print()
    
    # List drives
    print("MOUNTED DRIVES/VOLUMES:")
    print("-" * 70)
    drives = list_windows_drives()
    for drive in drives:
        print(f"  {drive}")
    print()
    
    # Get scan path
    scan_root = input("Enter path to scan (e.g., G:\\ for mounted image): ").strip()
    
    if not scan_root:
        print("ERROR: No scan path provided. Exiting.")
        return
    
    if not os.path.exists(scan_root):
        print(f"ERROR: Path does not exist: {scan_root}")
        return
    
    if not os.path.isdir(scan_root):
        print(f"ERROR: Path is not a directory: {scan_root}")
        return
    
    # Get output CSV path
    output_csv = input("Enter output CSV path (e.g., scan_results.csv): ").strip()
    
    if not output_csv:
        print("ERROR: No output path provided. Exiting.")
        return
    
    # Start scan
    print("\n" + "=" * 70)
    print("TARGET SCAN PATH:")
    print(f"  {os.path.abspath(scan_root)}")
    print("=" * 70)
    print("\nStarting recursive scan...\n")
    
    results: List[Dict] = []
    total_encountered = 0
    total_scanned = 0
    unreadable = 0
    suspicious_count = 0
    found_files: Set[str] = set()
    
    # Scan for File### pattern
    for root, dirs, files in os.walk(scan_root, topdown=True, followlinks=False):
        for filename in files:
            total_encountered += 1
            file_path = os.path.join(root, filename)
            
            # Progress every 10 files (show all files being scanned)
            if total_encountered % 10 == 0:
                print_progress(total_encountered, suspicious_count, file_path)
            
            # Check if filename matches File### pattern
            name_base = os.path.splitext(filename)[0]
            match = FILE_ID_PATTERN.match(name_base)
            if not match:
                continue
            
            num = int(match.group(1))
            if not (1 <= num <= 220):
                continue
            
            file_id = f"File{num:03d}"
            
            try:
                # Read header and content
                header = read_file_header(file_path, 50)
                content = read_file_sample(file_path, 1024 * 1024)
                
                # Detect type and malware indicators
                detected_type, signature = detect_file_type(file_path, header)
                matched_rules, risk_score, verdict = detect_malware_indicators(content)
                
                if verdict != "CLEAN":
                    suspicious_count += 1
                
                # Compute hash
                sha256_hash = compute_sha256(file_path)
                
                # Get metadata
                file_size = os.path.getsize(file_path)
                file_name = os.path.basename(file_path)
                first_50_hex = header.hex()
                
                results.append({
                    "file_path": file_path,
                    "file_name": file_name,
                    "file_size": str(file_size),
                    "sha256": sha256_hash,
                    "first_50_bytes_hex": first_50_hex,
                    "detected_type": detected_type,
                    "signature_match": signature,
                    "malware_rule_hits": ";".join(matched_rules),
                    "risk_score": str(risk_score),
                    "verdict": verdict,
                })
                
                total_scanned += 1
                found_files.add(file_id)
                
            except (OSError, IOError, PermissionError):
                unreadable += 1
                continue
    
    # Write CSV
    print("\nWriting CSV report...")
    write_csv_report(results, output_csv)
    print(f"CSV saved to: {os.path.abspath(output_csv)}")
    
    # Print summary
    print_summary(total_encountered, total_scanned, suspicious_count, unreadable, results)


# =============================================================================
# ENTRY POINT
# =============================================================================

if __name__ == "__main__":
    main()
